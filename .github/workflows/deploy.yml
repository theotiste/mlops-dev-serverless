name: deploy-dev

on:
  push:
    branches: [main]
    paths:
      - "serverless.yml"
      - "handler.py"
      - ".github/workflows/deploy-dev.yml"
      - "features_input.json"   # si tu veux tester /predict quand présent

concurrency:
  group: deploy-dev-${{ github.ref }}
  cancel-in-progress: true

env:
  SERVICE_NAME: cancer-prediction-api
  STAGE: dev
  AWS_REGION: eu-west-3

jobs:
  deploy-dev:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Node pour Serverless + plugin
      - name: Setup Node (cache npm)
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install Serverless CLI & plugin alerts
        run: |
          npm i -g serverless@^4
          npm i -D serverless-plugin-aws-alerts

      # Python (pour outillage éventuel) + jq pour smoke-tests
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install CLI tools
        run: sudo apt-get update -y >/dev/null && sudo apt-get install -y jq >/dev/null

      - name: Show versions
        run: |
          node -v
          npm -v
          serverless -v
          python --version

      # Auth AWS + Serverless Dashboard (clé d’accès)
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install project deps (plugins)
        run: npm ci   

      - name: Validate Serverless config
        env:
          SERVERLESS_ACCESS_KEY: ${{ secrets.SERVERLESS_ACCESS_KEY }}
        run: serverless print --stage $STAGE --region $AWS_REGION >/dev/null

      - name: Deploy (${{ env.STAGE }})
        env:
          SERVERLESS_ACCESS_KEY: ${{ secrets.SERVERLESS_ACCESS_KEY }}
        run: serverless deploy --stage $STAGE --region $AWS_REGION --conceal

      # Récupérer l’URL de base depuis "sls info"
      - name: Fetch API base URL from CloudFormation
        id: api
        env:
          SERVERLESS_ACCESS_KEY: ${{ secrets.SERVERLESS_ACCESS_KEY }}
        run: |
          serverless info --stage $STAGE --region $AWS_REGION > sls-info.txt
          # Prend la première ligne GET https://.../health et retire /health
          BASE_URL=$(grep -Eo 'GET - https://[^ ]+/health' sls-info.txt | head -n1 | awk '{print $3}' | sed 's#/health$##')
          echo "base_url=$BASE_URL" >> $GITHUB_OUTPUT
          echo "API Base URL: $BASE_URL"

      - name: Smoke test /health
        env:
          URL: ${{ steps.api.outputs.base_url }}/health
        run: |
          set -euo pipefail
          echo "Health URL: $URL"
          for i in 1 2 3 4 5; do
            if curl -sS "$URL" | jq -e '.ok == true' >/dev/null; then
              echo "OK /health"
              exit 0
            fi
            echo "Retry ($i/5)…"
            sleep 5
          done
          echo "Health check failed."
          exit 1

      # (Optionnel) test /predict si un fichier features_input.json est présent
      - name: Smoke test /predict (optional if features_input.json exists)
        if: hashFiles('features_input.json') != ''
        env:
          URL: ${{ steps.api.outputs.base_url }}/predict
        run: |
          set -euo pipefail
          echo "Predict URL: $URL"
          curl -sS -X POST "$URL" \
            -H "Content-Type: application/json" \
            -d @features_input.json | jq -e '.predictions | length > 0' >/dev/null

      - name: Show endpoints (optional) and save
        run: |
          echo "=== endpoints ==="
          cat sls-info.txt || true
        # garder la sortie "sls info" en artifact
      - name: Upload sls info
        uses: actions/upload-artifact@v4
        with:
          name: sls-info
          path: sls-info.txt
          retention-days: 7

      # =========================
      # Monitoring CI: résumé + logs + alertes externes
      # =========================

      - name: Résumé du déploiement
        if: always()
        run: |
          {
            echo "## Déploiement ${{ env.STAGE }}"
            echo "- Service: **${{ env.SERVICE_NAME }}**"
            echo "- Région: **${{ env.AWS_REGION }}**"
            echo "- Base URL: **${{ steps.api.outputs.base_url || 'n/a' }}**"
            echo "- Résultat: **${{ job.status }}**"
            echo "- Commit: $GITHUB_SHA"
          } >> $GITHUB_STEP_SUMMARY

      - name: Dump latest Lambda logs (15m) on failure
        if: failure()
        run: |
          set -e
          STACK="${{ env.SERVICE_NAME }}-${{ env.STAGE }}"
          FN=$(aws cloudformation describe-stack-resources \
                --stack-name "$STACK" \
                --query "StackResources[?ResourceType=='AWS::Lambda::Function'].PhysicalResourceId" \
                --output text | head -n1)
          echo "Lambda: $FN"
          aws logs tail "/aws/lambda/$FN" --since 15m --format short || true

      - name: Notify Slack on failure (optional)
        if: failure() && env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          msg="❌ Deploy *${{ env.STAGE }}* FAILED – ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          curl -X POST -H 'Content-type: application/json' --data "{\"text\":\"$msg\"}" "$SLACK_WEBHOOK_URL"
